
    (function(){
      if(typeof window === 'undefined') return;
      if(!window.__webspatialsdk__) window.__webspatialsdk__ = {}
      window.__webspatialsdk__['core-sdk-version'] = "1.0.4"
  })()
    

// src/core/private/remote-command/RemoteCommand.ts
var RemoteCommand = class _RemoteCommand {
  static requestCounter = 0;
  command;
  data;
  requestID;
  constructor(cmd, data) {
    this.command = cmd;
    this.data = data;
    this.requestID = ++_RemoteCommand.requestCounter;
  }
};

// src/core/private/WebSpatial.ts
var WindowContainer = class {
  id = "";
};
var WebSpatialResource = class {
  id = "";
  windowContainerId = "";
  data = {};
  receiveEvent() {
  }
};
var WebSpatial = class _WebSpatial {
  static eventPromises = {};
  static transactionStarted = false;
  static transactionCommands = Array();
  // store event receivers
  static eventReceivers = {};
  static registerEventReceiver(resourceId, callback) {
    this.eventReceivers[resourceId] = callback;
  }
  static unregisterEventReceiver(resourceId) {
    delete this.eventReceivers[resourceId];
  }
  static init() {
    window.__SpatialWebEvent = (e) => {
      if (e.resourceId) {
        var callback = _WebSpatial.eventReceivers[e.resourceId];
        callback(e.data);
      } else {
        var p = _WebSpatial.eventPromises[e.requestID];
        if (p) {
          if (e.success) {
            p.res(e);
          } else {
            p.rej(e);
          }
        }
      }
    };
  }
  static startTransaction() {
    _WebSpatial.transactionStarted = true;
    _WebSpatial.transactionCommands = [];
  }
  static async sendTransaction() {
    _WebSpatial.transactionStarted = false;
    var cmd = new RemoteCommand("multiCommand", {
      commandList: _WebSpatial.transactionCommands
    });
    var result = await new Promise((res, rej) => {
      _WebSpatial.eventPromises[cmd.requestID] = { res, rej };
      _WebSpatial.sendCommand(cmd);
    });
    return result;
  }
  static getBackend() {
    if (window.webkit) {
      return "AVP";
    } else {
      return "UNKNOWN";
    }
  }
  static async sendCommand(cmd) {
    if (window.__WebSpatialUnloaded) {
      return;
    }
    if (_WebSpatial.transactionStarted) {
      _WebSpatial.transactionCommands.push(cmd);
      return;
    }
    var msg = JSON.stringify(cmd);
    if (_WebSpatial.getBackend() == "AVP") {
      window.webkit.messageHandlers.bridge.postMessage(msg);
      return;
    } else {
      window.__WebSpatialData.androidNativeMessage(msg);
      return;
    }
  }
  static getImmersiveWindowContainer() {
    var wg = new WindowContainer();
    wg.id = "Immersive";
    return wg;
  }
  static getCurrentWindowContainer() {
    var wg = new WindowContainer();
    wg.id = "current";
    return wg;
  }
  static getCurrentWebPanel() {
    var wg = new WebSpatialResource();
    wg.id = "current";
    wg.windowContainerId = _WebSpatial.getCurrentWindowContainer().id;
    return wg;
  }
  static async createScene(style = "Plain", cfg) {
    const { window: newWindow, ...sceneData } = cfg.sceneData;
    const jsbSceneData = {
      ...sceneData,
      windowID: newWindow._webSpatialID,
      windowContainerID: newWindow._webSpatialGroupID
    };
    var cmd = new RemoteCommand("createScene", {
      windowStyle: style,
      sceneData: jsbSceneData,
      windowContainerID: window._webSpatialParentGroupID
      // parent WindowContainerID
    });
    try {
      await new Promise((res, rej) => {
        _WebSpatial.eventPromises[cmd.requestID] = { res, rej };
        _WebSpatial.sendCommand(cmd);
      });
      return true;
    } catch (error) {
      return false;
    }
  }
  static async createWindowContainer(style = "Plain", windowContainer, parentWebView) {
    var cmd = new RemoteCommand("createWindowContainer", {
      windowStyle: style,
      windowContainerID: windowContainer ? windowContainer.id : void 0,
      resourceID: parentWebView ? parentWebView.id : void 0
    });
    var result = await new Promise((res2, rej) => {
      _WebSpatial.eventPromises[cmd.requestID] = { res: res2, rej };
      _WebSpatial.sendCommand(cmd);
    });
    var res = new WindowContainer();
    res.id = result.data.createdID;
    return res;
  }
  static async destroyResource(resource) {
    const data = {};
    var cmd = new RemoteCommand("destroyResource", {
      windowContainerID: resource.windowContainerId,
      resourceID: resource.id
    });
    _WebSpatial.sendCommand(cmd);
  }
  static async ping(msg) {
    var cmd = new RemoteCommand("ping", {
      windowContainerID: this.getCurrentWindowContainer().id,
      resourceID: this.getCurrentWebPanel().id,
      message: msg
    });
    if (_WebSpatial.transactionStarted) {
      _WebSpatial.sendCommand(cmd);
      return null;
    } else {
      var result = await new Promise((res, rej) => {
        _WebSpatial.eventPromises[cmd.requestID] = { res, rej };
        _WebSpatial.sendCommand(cmd);
      });
      return result;
    }
  }
  static async getStats() {
    var cmd = new RemoteCommand("getStats", {
      windowContainerID: this.getCurrentWindowContainer().id,
      resourceID: this.getCurrentWebPanel().id
    });
    var result = await new Promise((res, rej) => {
      _WebSpatial.eventPromises[cmd.requestID] = { res, rej };
      _WebSpatial.sendCommand(cmd);
    });
    return result.data;
  }
  static async inspect(spatialObjectId) {
    var cmd = new RemoteCommand("inspect", {
      resourceID: spatialObjectId
    });
    var result = await new Promise((res, rej) => {
      _WebSpatial.eventPromises[cmd.requestID] = { res, rej };
      _WebSpatial.sendCommand(cmd);
    });
    return result.data;
  }
  static async inspectRootWindowContainer() {
    return this.inspect("root");
  }
  static async setComponent(entity, resource) {
    var cmd = new RemoteCommand("setComponent", {
      windowContainerID: entity.windowContainerId,
      resourceID: resource.id,
      entityID: entity.id
    });
    _WebSpatial.sendCommand(cmd);
  }
  static async removeComponent(entity, resource) {
    var cmd = new RemoteCommand("removeComponent", {
      windowContainerID: entity.windowContainerId,
      resourceID: resource.id,
      entityID: entity.id
    });
    _WebSpatial.sendCommand(cmd);
  }
  // windowContainer is the group the resource will be tied to (if not provided it will use the current window grou)
  // parentWebView is the SpatialWebView that the resource will be tied to (if not provided, resource will continue to exist even if this page is unloaded)
  static async createResource(type, windowContainer, parentWebView, params = {}) {
    var cmd = new RemoteCommand("createResource", {
      windowContainerID: windowContainer ? windowContainer.id : void 0,
      resourceID: parentWebView ? parentWebView.id : void 0,
      type,
      params
    });
    var result = await new Promise((res2, rej) => {
      _WebSpatial.eventPromises[cmd.requestID] = { res: res2, rej };
      _WebSpatial.sendCommand(cmd);
    });
    var res = new WebSpatialResource();
    res.id = result.data.createdID;
    res.windowContainerId = cmd.data.windowContainerID;
    return res;
  }
  static async updateWindowContainer(wg, data) {
    var cmd = new RemoteCommand("updateWindowContainer", {
      windowContainerID: wg.id,
      update: data
    });
    var result = await new Promise((res, rej) => {
      _WebSpatial.eventPromises[cmd.requestID] = { res, rej };
      _WebSpatial.sendCommand(cmd);
    });
    return result;
  }
  static async updateResource(resource, data = null) {
    var cmd = new RemoteCommand("updateResource", {
      windowContainerID: resource.windowContainerId,
      resourceID: resource.id,
      update: data || resource.data
    });
    var result = await new Promise((res, rej) => {
      _WebSpatial.eventPromises[cmd.requestID] = { res, rej };
      _WebSpatial.sendCommand(cmd);
    });
    return result;
  }
  static async setLoading(method, style) {
    var cmd = new RemoteCommand("setLoading", {
      windowContainerID: window._webSpatialParentGroupID,
      // parent WindowContainerID
      loading: {
        method,
        style
      }
    });
    var result = await new Promise((res, rej) => {
      _WebSpatial.eventPromises[cmd.requestID] = { res, rej };
      _WebSpatial.sendCommand(cmd);
    });
    return result;
  }
  static async openImmersiveSpace() {
    var cmd = new RemoteCommand("openImmersiveSpace");
    await _WebSpatial.sendCommand(cmd);
  }
  static async dismissImmersiveSpace() {
    var cmd = new RemoteCommand("dismissImmersiveSpace");
    await _WebSpatial.sendCommand(cmd);
  }
  static onFrame(fn) {
    var dt = 0;
    var loop = async () => {
      var curTime = window.performance.now();
      await fn(curTime);
      var updateTime = window.performance.now() - curTime;
      setTimeout(
        () => {
          loop();
        },
        Math.max(1e3 / 60 - updateTime, 0)
      );
    };
    loop();
  }
};
WebSpatial.init();

// src/core/SpatialObject.ts
var SpatialObject = class {
  /** @hidden */
  constructor(_resource) {
    this._resource = _resource;
  }
  /**
   * Marks resource to be released (it should no longer be used)
   */
  async destroy() {
    await WebSpatial.destroyResource(this._resource);
    await this.onDestroy();
  }
  name = "";
  async onDestroy() {
  }
};

// src/core/SpatialTransform.ts
var Vec3 = class {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
};
var Vec4 = class {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
};
var SpatialTransform = class {
  position = new Vec3(0, 0, 0);
  /** Quaternion value for x,y,z,w */
  orientation = new Vec4(0, 0, 0, 1);
  scale = new Vec3(1, 1, 1);
};

// src/core/SpatialEntity.ts
var SpatialEntity = class extends SpatialObject {
  /**
   * Transform corresponding to the entity
   * note: updateTransform must be called for transform to be synced to rendering
   */
  transform = new SpatialTransform();
  /** @hidden */
  _destroyed = false;
  /** @hidden */
  get _entity() {
    return this._resource;
  }
  /**
   * Syncs the transform with the renderer, must be called to observe updates
   */
  async updateTransform() {
    await WebSpatial.updateResource(this._entity, this.transform);
  }
  /**
   * Syncs the zIndex with the renderer
   */
  async updateZIndex(zIndex) {
    await WebSpatial.updateResource(this._entity, { zIndex });
  }
  components = /* @__PURE__ */ new Map();
  /**
   * Attaches a component to the entity to be displayed
   * [TODO] review pass by value vs ref and ownership model for this
   */
  async setComponent(component) {
    await WebSpatial.setComponent(this._entity, component._resource);
    this.components.set(component.constructor, component);
  }
  /**
   * Removes a component from the entity
   */
  async removeComponent(type) {
    var c = this.getComponent(type);
    if (c != void 0) {
      await WebSpatial.removeComponent(this._entity, c._resource);
      this.components.delete(c.constructor);
    }
  }
  /**
   * Gets a component from the entity
   */
  getComponent(type) {
    return this.components.get(type);
  }
  /**
   * @hidden
   * Sets the window container that this entity should be rendered by (this does not effect resource ownership)
   * @param wg the window container that should render this entity
   */
  async _setParentWindowContainer(wg) {
    await WebSpatial.updateResource(this._entity, {
      setParentWindowContainerID: wg._wg.id
    });
  }
  /**
   * Sets a parent entity, if that entity or its parents are attached to a window container, this entity will be displayed
   * @param e parent entity or null to remove current parent
   */
  async setParent(e) {
    await WebSpatial.updateResource(this._entity, {
      setParent: e ? e._entity.id : ""
    });
  }
  /**
   * Sets the coordinate space of this entity (Default: App)
   * "App" = game engine style coordinates in meters
   * "Dom" = Windowing coordinates in dom units (eg. 0,0,0 is top left of window)
   * "Root" = Coordinate space is ignored and content is displayed and updated as window container's root object, window containers can only have one root entity
   * [TODO] review this api
   * @param space coordinate space mode
   */
  async setCoordinateSpace(space) {
    await WebSpatial.updateResource(this._entity, { setCoordinateSpace: space });
  }
  /**
   * Query the 3d boudning box of the entity
   * @returns The bounding box of the entity
   */
  async getBoundingBox() {
    var res = await WebSpatial.updateResource(this._entity, {
      getBoundingBox: true
    });
    return res.data;
  }
  /**
   * Sets if the entity should be visible (default: True)
   * @param visible
   */
  async setVisible(visible) {
    await WebSpatial.updateResource(this._entity, { visible });
  }
  /**
   * Removes a reference to the entity by the renderer and this object should no longer be used. [TODO] Attached components will not be destroyed
   */
  async destroy() {
    this._destroyed = true;
    await WebSpatial.destroyResource(this._entity);
  }
  /**
   * Check if destroy has been called
   */
  isDestroyed() {
    return this._destroyed;
  }
  // Set Entity name. Currently for debugging only.
  /** @hidden */
  async _setName(name) {
    this.name = name;
    return WebSpatial.updateResource(this._entity, { name });
  }
};

// src/core/component/SpatialComponent.ts
var SpatialComponent = class extends SpatialObject {
  /**
   * Gets the entity this component is attached to
   * @returns entity or null
   */
  async getEntity() {
    let reqResp = await WebSpatial.updateResource(
      WebSpatial.getCurrentWebPanel(),
      { getEntityID: "" }
    );
    if (reqResp.data.parentID === "") {
      return new Promise((res2, rej) => {
        res2(null);
      });
    } else {
      var res = new WebSpatialResource();
      res.id = reqResp.data.parentID;
      return new SpatialEntity(res);
    }
  }
};

// src/core/SpatialWindowContainer.ts
var SpatialWindowContainer = class {
  /** @hidden */
  constructor(_wg) {
    this._wg = _wg;
  }
  /**
   * @hidden
   * Sets sets the open configuration for opening new window containers
   * @param options style options
   */
  async _setOpenSettings(options) {
    await WebSpatial.updateWindowContainer(this._wg, {
      nextOpenSettings: options
    });
  }
  /**
   * Retrieves the root entity of the windowContainer
   * @returns the root entity of the windowContainer if one exists
   */
  async getRootEntity() {
    let reqResp = await WebSpatial.updateWindowContainer(this._wg, {
      getRootEntityID: ""
    });
    if (reqResp.data.rootEntId === "") {
      return null;
    } else {
      var res = new WebSpatialResource();
      res.id = reqResp.data.rootEntId;
      return new SpatialEntity(res);
    }
  }
  /*
   * Sets the root entity that this windowContainer will display (this does not effect resource ownership)
   * @param entity to display
   */
  async setRootEntity(entity) {
    await entity._setParentWindowContainer(this);
  }
  async close() {
    await WebSpatial.updateWindowContainer(this._wg, {
      close: true
    });
  }
};

// src/core/resource/SpatialMeshResource.ts
var SpatialMeshResource = class extends SpatialObject {
};

// src/core/resource/SpatialPhysicallyBasedMaterialResource.ts
var SpatialPhysicallyBasedMaterialResource = class extends SpatialObject {
  /**
   * Base color of the material containing rgba between 0 and 1
   */
  baseColor = { r: 0, g: 0.7, b: 0.7, a: 1 };
  /**
   * PBR metalic value between 0 and 1
   */
  metallic = { value: 0.5 };
  /**
   * PBR roughness value between 0 and 1
   */
  roughness = { value: 0.5 };
  _modelComponentAttachedTo = {};
  _addToComponent(c) {
    this._modelComponentAttachedTo[c._resource.id] = c;
  }
  /**
   * Syncs state of color, metallic, roupghness to the renderer
   */
  async update() {
    await WebSpatial.updateResource(this._resource, {
      baseColor: this.baseColor,
      metallic: this.metallic,
      roughness: this.roughness
    });
    for (var key in this._modelComponentAttachedTo) {
      await this._modelComponentAttachedTo[key]._syncMaterials();
    }
  }
};

// src/core/SpatialSession.ts
function _parseParentResources(options) {
  var parentWindowContainer = null;
  if (options?.windowContainer !== null) {
    parentWindowContainer = options?.windowContainer ? options?.windowContainer._wg : WebSpatial.getCurrentWindowContainer();
  }
  var parentWindow = null;
  if (options?.windowComponent !== null) {
    parentWindow = options?.windowComponent ? options?.windowComponent._resource : WebSpatial.getCurrentWebPanel();
  }
  return [parentWindowContainer, parentWindow];
}
var SpatialSession = class _SpatialSession {
  /** @hidden */
  _engineUpdateListeners = Array();
  /** @hidden */
  _frameLoopStarted = false;
  /**
   * Add event listener callback to be called each frame
   * @param callback callback to be called each update
   */
  addOnEngineUpdateEventListener(callback) {
    this._engineUpdateListeners.push(callback);
    if (!this._frameLoopStarted) {
      this._frameLoopStarted = true;
      WebSpatial.onFrame(async (time) => {
        await Promise.all(
          this._engineUpdateListeners.map((cb) => {
            return cb(time);
          })
        );
      });
    }
  }
  /**
   * Creates a Entity
   * @returns Entity
   */
  async createEntity(options) {
    var [parentWindowContainer, parentWindow] = _parseParentResources(options);
    let entity = await WebSpatial.createResource(
      "Entity",
      parentWindowContainer,
      parentWindow
    );
    return new SpatialEntity(entity);
  }
  /**
   * Creates a WindowComponent
   * [TODO] should creation of components be moved to entity? and these made private?
   * @returns WindowComponent
   */
  async createWindowComponent(options) {
    var [parentWindowContainer, parentWindow] = _parseParentResources(options);
    let entity = await WebSpatial.createResource(
      "SpatialWebView",
      parentWindowContainer,
      parentWindow
    );
    return new SpatialWindowComponent(entity);
  }
  /**
   * Creates a ViewComponent used to display 3D content within the entity
   * @returns SpatialViewComponent
   */
  async createViewComponent(options) {
    var [parentWindowContainer, parentWindow] = _parseParentResources(options);
    let entity = await WebSpatial.createResource(
      "SpatialView",
      parentWindowContainer,
      parentWindow
    );
    return new SpatialViewComponent(entity);
  }
  /**
   * Creates a ModelComponent used to display geometry + material of a 3D model
   * @returns ModelComponent
   */
  async createModelComponent(options) {
    var [parentWindowContainer, parentWindow] = _parseParentResources(options);
    var opts = void 0;
    if (options) {
      opts = { modelURL: options.url };
    }
    let entity = await WebSpatial.createResource(
      "ModelComponent",
      parentWindowContainer,
      parentWindow,
      opts
    );
    return new SpatialModelComponent(entity);
  }
  /**
   * Creates a Model3DComponent
   * @returns Model3DComponent
   */
  async createModel3DComponent(options) {
    var [parentWindowContainer, parentWindow] = _parseParentResources(options);
    var opts = void 0;
    if (options) {
      opts = { modelURL: options.url };
    }
    let entity = await WebSpatial.createResource(
      "Model3DComponent",
      parentWindowContainer,
      parentWindow,
      opts
    );
    return new SpatialModel3DComponent(entity);
  }
  /**
   * Creates a InputComponent
   * [Experimental] Creates a InputComponent used to handle click and drag events of the entity containing a model
   * @returns InputComponent
   */
  async createInputComponent(options) {
    var [parentWindowContainer, parentWindow] = _parseParentResources(options);
    let entity = await WebSpatial.createResource(
      "InputComponent",
      parentWindowContainer,
      parentWindow
    );
    return new SpatialInputComponent(entity);
  }
  /**
   * Creates a MeshResource containing geometry data
   * @returns MeshResource
   */
  async createMeshResource(options) {
    var [parentWindowContainer, parentWindow] = _parseParentResources(options);
    let entity = await WebSpatial.createResource(
      "MeshResource",
      parentWindowContainer,
      parentWindow,
      options
    );
    return new SpatialMeshResource(entity);
  }
  /**
   * Creates a PhysicallyBasedMaterial containing PBR material data
   * @returns PhysicallyBasedMaterial
   */
  async createPhysicallyBasedMaterialResource(options) {
    var [parentWindowContainer, parentWindow] = _parseParentResources(options);
    let entity = await WebSpatial.createResource(
      "PhysicallyBasedMaterial",
      parentWindowContainer,
      parentWindow,
      options
    );
    return new SpatialPhysicallyBasedMaterialResource(entity);
  }
  /**
   * Creates a WindowContainer
   * @returns SpatialWindowContainer
   * */
  async createWindowContainer(options) {
    var style = options?.style ? options?.style : "Plain";
    var [parentWindowContainer, parentWindow] = _parseParentResources(options);
    return new SpatialWindowContainer(
      await WebSpatial.createWindowContainer(
        style,
        parentWindowContainer,
        parentWindow
      )
    );
  }
  /**
   * Creates a Scene to display content within an anchored area managed by the OS
   * @hidden
   * @param {WindowStyle} [style='Plain'] - The style of the Scene container to be created with. Defaults to 'Plain'.
   * @param {Object} [cfg={}] - Configuration object for the Scene.
   * @returns Boolean
   */
  async _createScene(style = "Plain", cfg) {
    return await WebSpatial.createScene(style, cfg);
  }
  /**
   * Retrieves the window for this page
   * @returns the window component corresponding to the js running on this page
   * [TODO] discuss implications of this not being async
   */
  getCurrentWindowComponent() {
    return new SpatialWindowComponent(WebSpatial.getCurrentWebPanel());
  }
  /**
   * Retrieves the parent window for this page or null if this is the root page
   * @returns the window component or null
   */
  async getParentWindowComponent() {
    let parentResp = await WebSpatial.updateResource(
      WebSpatial.getCurrentWebPanel(),
      { getParentID: "" }
    );
    if (parentResp.data.parentID === "") {
      return new Promise((res2, rej) => {
        res2(null);
      });
    } else {
      var res = new WebSpatialResource();
      res.id = parentResp.data.parentID;
      return new SpatialWindowComponent(res);
    }
  }
  /**
   * Logs a message to the native apps console
   * @param msg mesage to log
   */
  async log(...msg) {
    await WebSpatial.sendCommand(
      new RemoteCommand("log", {
        logString: msg.map((x) => {
          return JSON.stringify(x);
        })
      })
    );
  }
  /**
   * @hidden
   * Debugging only, used to ping the native renderer
   */
  async _ping(msg) {
    return await WebSpatial.ping(msg);
  }
  /**
   * @hidden
   * Debugging to get internal state from native code
   * @returns stats from native code. Objects tracks number of native objects that were created but not yet explicitly destroyed. RefObjects tracks bjects that still have references. After an object is destroyed, we should be cleaning up all of the native references. Expect objects.count == refObjects.count , if not, there is likely a leak.
   */
  async _getStats() {
    return await WebSpatial.getStats();
  }
  /**
   * @hidden
   */
  async _inspect(spatialObjectId = WebSpatial.getCurrentWebPanel().id) {
    return WebSpatial.inspect(spatialObjectId);
  }
  /**
   * @hidden
   */
  async _inspectRootWindowContainer() {
    return WebSpatial.inspectRootWindowContainer();
  }
  /** Opens the immersive space */
  async openImmersiveSpace() {
    return await WebSpatial.openImmersiveSpace();
  }
  /** Closes the immersive space */
  async dismissImmersiveSpace() {
    return await WebSpatial.dismissImmersiveSpace();
  }
  static _immersiveWindowContainer = null;
  /**
   * Retreives the window container corresponding to the Immersive space
   * @returns the immersive window container
   */
  async getImmersiveWindowContainer() {
    if (_SpatialSession._immersiveWindowContainer) {
      return _SpatialSession._immersiveWindowContainer;
    } else {
      _SpatialSession._immersiveWindowContainer = new SpatialWindowContainer(
        WebSpatial.getImmersiveWindowContainer()
      );
      return _SpatialSession._immersiveWindowContainer;
    }
  }
  // Retreives the window container that is the parent to this spatial web page
  static _currentWindowContainer = null;
  /**
   * Gets the current window container for the window
   * [TODO] discuss what happens if it doesnt yet have a window container
   * @returns the current window container for the window
   */
  getCurrentWindowContainer() {
    if (_SpatialSession._currentWindowContainer) {
      return _SpatialSession._currentWindowContainer;
    } else {
      _SpatialSession._currentWindowContainer = new SpatialWindowContainer(
        WebSpatial.getCurrentWindowContainer()
      );
      return _SpatialSession._currentWindowContainer;
    }
  }
  /**
   * Start a transaction that queues up commands to submit them all at once to reduce ipc overhead
   * @param fn function to be run, within this function, promises will not resolve
   * @returns promise for the entire transaction completion
   */
  transaction(fn) {
    WebSpatial.startTransaction();
    fn();
    return WebSpatial.sendTransaction();
  }
  /**
   * Creates a window context object that is compatable with SpatialWindowComponent's setFromWindow API
   * @returns window context
   */
  async createWindowContext() {
    let openedWindow = window.open("webspatial://createWindowContext");
    if (WebSpatial.getBackend() != "AVP") {
      var counter = 0;
      while (openedWindow.window.testAPI == null) {
        if (counter > 15) {
          openedWindow?.close();
          openedWindow = window.open("about:blank");
          counter = 0;
          this.log("unexpected error when trying to open new window, retrying.");
        }
        var locName = "about:blank?x" + counter;
        openedWindow.location.href = locName;
        counter++;
        await new Promise((resolve) => setTimeout(resolve, 10));
      }
      ;
      openedWindow._webSpatialID = openedWindow.window.testAPI.getWindowID();
    } else {
      while (openedWindow.window._webSpatialID == void 0) {
        await new Promise((resolve) => setTimeout(resolve, 10));
      }
    }
    openedWindow.document.head.innerHTML = `<meta name="viewport" content="width=device-width, initial-scale=1">
      <base href="${document.baseURI}">
      `;
    return openedWindow;
  }
  // Get Entity by id. Currently for debugging only.
  /** @hidden */
  async _getEntity(id) {
    const entityInfo = await WebSpatial.inspect(id);
    const [_, x, y, z] = entityInfo.position.match(/(\d+\.?\d*)/g);
    const [__, sx, sy, sz] = entityInfo.scale.match(/(\d+\.?\d*)/g);
    var res = new WebSpatialResource();
    res.id = id;
    res.windowContainerId = WebSpatial.getCurrentWindowContainer().id;
    const entity = new SpatialEntity(res);
    entity.transform.position.x = parseFloat(x);
    entity.transform.position.y = parseFloat(y);
    entity.transform.position.z = parseFloat(z);
    entity.transform.scale.x = parseFloat(sx);
    entity.transform.scale.y = parseFloat(sy);
    entity.transform.scale.z = parseFloat(sz);
    return entity;
  }
  // set loading view.
  /** @hidden */
  async setLoading(method, style) {
    return WebSpatial.setLoading(method, style);
  }
};

// src/core/Spatial.ts
var Spatial = class {
  /**
   * Requests a session object from the browser
   * @returns The session or null if not availible in the current browser
   * [TODO] discuss implications of this not being async
   */
  requestSession() {
    if (this.isSupported() && this.getNativeVersion() === this.getClientVersion()) {
      return new SpatialSession();
    } else {
      return null;
    }
  }
  /**
   * @returns true if web spatial is supported by this webpage
   */
  isSupported() {
    return this.getNativeVersion() === this.getClientVersion();
  }
  /**
   * Gets the native version, format is "x.x.x"
   * @returns native version string
   */
  getNativeVersion() {
    if (window.__WebSpatialData && window.__WebSpatialData.getNativeVersion) {
      return window.__WebSpatialData.getNativeVersion();
    }
    return window.WebSpatailNativeVersion === "PACKAGE_VERSION" ? this.getClientVersion() : window.WebSpatailNativeVersion;
  }
  /**
   * Gets the client version, format is "x.x.x"
   * @returns client version string
   */
  getClientVersion() {
    return "1.0.4";
  }
};

// src/core/SpatialHelper.ts
var SpatialHelper = class _SpatialHelper {
  constructor(session) {
    this.session = session;
  }
  static _instance = null;
  static get instance() {
    if (this._instance) {
      return this._instance;
    } else {
      let spatial = new Spatial();
      if (spatial.isSupported()) {
        let session = spatial.requestSession();
        if (session) {
          this._instance = new _SpatialHelper(session);
          return this._instance;
        }
      }
    }
    return null;
  }
  shape = {
    createShapeEntity: async (shape = "box") => {
      var box = await this.session.createMeshResource({ shape });
      var mat = await this.session.createPhysicallyBasedMaterialResource();
      await mat.update();
      var customModel = await this.session.createModelComponent();
      customModel.setMaterials([mat]);
      customModel.setMesh(box);
      var boxEntity = await this.session.createEntity();
      await boxEntity.setComponent(customModel);
      boxEntity.transform.position.z = 0;
      boxEntity.transform.scale = new Vec3(0.5, 0.5, 0.5);
      await boxEntity.updateTransform();
      return boxEntity;
    },
    createModelEntity: async (url) => {
      var customModel = await this.session.createModelComponent({ url });
      var boxEntity = await this.session.createEntity();
      await boxEntity.setComponent(customModel);
      await boxEntity.updateTransform();
      return boxEntity;
    },
    wrapInBoundingBoxEntity: async (entityToWrap) => {
      var bb = await entityToWrap.getBoundingBox();
      var targetSize = 1;
      var scale = targetSize / Math.max(bb.extents.x, bb.extents.y, bb.extents.z);
      entityToWrap.transform.scale.x = scale;
      entityToWrap.transform.scale.y = scale;
      entityToWrap.transform.scale.z = scale;
      entityToWrap.transform.position.x = -bb.center.x * scale;
      entityToWrap.transform.position.y = -bb.center.y * scale;
      entityToWrap.transform.position.z = -bb.center.z * scale;
      await entityToWrap.updateTransform();
      var boudningEntity = await _SpatialHelper.instance?.session.createEntity();
      await entityToWrap.setParent(boudningEntity);
      return boudningEntity;
    }
  };
  navigation = {
    openPanel: async (url, options) => {
      if (options?.resolution) {
        await this.session.getCurrentWindowContainer()._setOpenSettings({ resolution: options.resolution });
      }
      var wg = await this.session.createWindowContainer({
        style: "Plain",
        windowComponent: null,
        windowContainer: null
      });
      var ent = await this.session.createEntity({
        windowComponent: null,
        windowContainer: wg
      });
      var i = await this.session.createWindowComponent({
        windowComponent: null,
        windowContainer: wg
      });
      await i.loadURL(url);
      await ent.setCoordinateSpace("Root");
      await ent.setComponent(i);
      await wg.setRootEntity(ent);
      await this.session.getCurrentWindowContainer()._setOpenSettings({ resolution: { width: 900, height: 700 } });
      return {
        windowContainer: wg
      };
    },
    openVolume: async (url, options) => {
      var wg = await this.session.createWindowContainer({
        style: "Volumetric",
        windowComponent: null,
        windowContainer: null
      });
      var rootEnt = await this.session.createEntity({
        windowComponent: null,
        windowContainer: wg
      });
      await rootEnt.setComponent(
        await this.session.createViewComponent({
          windowComponent: null,
          windowContainer: wg
        })
      );
      await rootEnt.setCoordinateSpace("Root");
      await wg.setRootEntity(rootEnt);
      var ent = await this.session.createEntity({
        windowComponent: null,
        windowContainer: wg
      });
      var i = await this.session.createWindowComponent({
        windowComponent: null,
        windowContainer: wg
      });
      await i.loadURL(url);
      if (options?.resolution) {
        await i.setResolution(
          options.resolution.width,
          options.resolution.height
        );
      } else {
        await i.setResolution(1e3, 1e3);
      }
      ent.transform.position.z = -0.49;
      await ent.updateTransform();
      await ent.setCoordinateSpace("App");
      await ent.setComponent(i);
      await ent.setParent(rootEnt);
    }
  };
  dom = {
    attachSpatialView: async (divOnPage) => {
      var viewEnt = await this.session.createEntity();
      await viewEnt.setCoordinateSpace("Dom");
      await viewEnt.setComponent(await this.session.createViewComponent());
      var wc = await this.session.getCurrentWindowComponent();
      var ent = await wc.getEntity();
      await viewEnt.setParent(ent);
      var update = () => {
        var rect = divOnPage.getBoundingClientRect();
        viewEnt.transform.position.x = rect.x + rect.width / 2;
        viewEnt.transform.position.y = rect.y + rect.height / 2 + window.scrollY;
        viewEnt.updateTransform();
        viewEnt.getComponent(SpatialViewComponent).setResolution(rect.width, rect.height);
      };
      var mo = new MutationObserver(update);
      mo.observe(divOnPage, { attributes: true });
      var ro = new ResizeObserver(update);
      ro.observe(divOnPage);
      const addRemoveObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.removedNodes.forEach((node) => {
            if (node instanceof HTMLElement) {
              update();
            }
          });
          mutation.addedNodes.forEach((node) => {
            if (node instanceof HTMLElement) {
              update();
            }
          });
        });
      });
      addRemoveObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
      update();
      return {
        entity: viewEnt
      };
    }
  };
  setBackgroundStyle = async (style, backgroundColor = "#00000000") => {
    document.documentElement.style.backgroundColor = backgroundColor;
    await this.session.getCurrentWindowComponent().setStyle(style);
  };
};

// src/core/component/SpatialWindowComponent.ts
var SpatialWindowComponent = class extends SpatialComponent {
  /**
   * Loads a url page in the window
   * @param url url to load
   */
  async loadURL(url) {
    await WebSpatial.updateResource(this._resource, { url });
  }
  async setFromWindow(window2) {
    if (window2._webSpatialID) {
      await WebSpatial.updateResource(this._resource, {
        windowID: window2._webSpatialID
      });
    } else {
      await console.warn(
        "failed to call setFromWindow, window provided is not valid"
      );
    }
  }
  /**
   * Sets the resolution of the window, the resulting dimensions when rendered will be equal to 1/1360 units
   * eg. if the resolution is set to 1360x1360 it will be a 1x1 plane
   * See 1360 in spatialViewUI.swift for how this ratio works
   * @param width width in pixels
   * @param height height in pixels
   */
  async setResolution(width, height) {
    await WebSpatial.updateResource(this._resource, {
      resolution: { x: width, y: height }
    });
  }
  /**
   * [Experimental] Sets the anchor which the entity this is attached to will rotate around
   * @param rotationAnchor
   */
  async setRotationAnchor(rotationAnchor) {
    await WebSpatial.updateResource(this._resource, {
      rotationAnchor
    });
  }
  /**
   * [Experimental] Sets the opacity of the window after apply material
   * @param opacity
   */
  async setOpacity(opacity) {
    await WebSpatial.updateResource(this._resource, {
      opacity
    });
  }
  /**
   * Sets the style that should be applied to the window
   * @param options style options
   */
  async setStyle(styleParam) {
    const currentWindowComponent = SpatialHelper.instance?.session.getCurrentWindowComponent();
    const isSettingSelfStyle = currentWindowComponent?._resource.id == this._resource.id;
    const { material, cornerRadius } = styleParam;
    const options = {};
    if (material?.type) {
      options.backgroundMaterial = material.type;
    }
    if (cornerRadius !== void 0) {
      if (typeof cornerRadius === "number") {
        options.cornerRadius = {
          topLeading: cornerRadius,
          bottomLeading: cornerRadius,
          topTrailing: cornerRadius,
          bottomTrailing: cornerRadius
        };
      } else {
        options.cornerRadius = { ...cornerRadius };
      }
    }
    if (isSettingSelfStyle && document && document.readyState == "loading") {
      var encoded = encodeURIComponent(JSON.stringify(options));
      const a = document.createElement(`a`);
      a.href = "forcestyle://mystyle.css?style=" + encoded;
      document.body.appendChild(a);
      a.click();
      a.remove();
    } else {
      await WebSpatial.updateResource(this._resource, { style: options });
    }
  }
  /**
   * Modifies the amount the spatial window can be scrolled
   * Should only be used internally
   * See https://developer.apple.com/documentation/uikit/1624475-uiedgeinsetsmake?language=objc
   * @param insets margin to modify scroll distances by
   */
  async setScrollEdgeInsets(insets) {
    await WebSpatial.updateResource(this._resource, {
      setScrollEdgeInsets: insets
    });
  }
  /**
   * Enable/Disable scrolling in the window (defaults to enabled), if disabled, scrolling will be applied to the root page
   * @param enabled value to set
   */
  async setScrollEnabled(enabled) {
    await WebSpatial.updateResource(this._resource, { scrollEnabled: enabled });
  }
  /**
   * Defaults to false. If set to true, scrolling the parent page will also scroll this window with it like other dom elements
   * @param scrollWithParent value to set
   */
  async setScrollWithParent(scrollWithParent) {
    await WebSpatial.updateResource(this._resource, {
      scrollWithParent
    });
  }
};

// src/core/component/EventSpatialComponent.ts
var EventSpatialComponent = class extends SpatialComponent {
  // Class implementation goes here
  constructor(_resource) {
    super(_resource);
    WebSpatial.registerEventReceiver(_resource.id, (data) => {
      this.onRecvEvent(data);
    });
  }
  async onDestroy() {
    WebSpatial.unregisterEventReceiver(this._resource.id);
  }
};

// src/core/component/SpatialInputComponent.ts
var SpatialInputComponent = class extends EventSpatialComponent {
  onRecvEvent(data) {
    this.onTranslate(data);
  }
  /**
   * Callback fired when a translate event occurs
   * @param data translate event data
   */
  onTranslate(data) {
  }
};

// src/core/component/SpatialModelComponent.ts
var SpatialModelComponent = class extends SpatialComponent {
  cachedMaterials = new Array();
  /**
   * Sets the mesh to be displayed by the component
   * @param mesh mesh to set
   */
  async setMesh(mesh) {
    await WebSpatial.updateResource(this._resource, {
      meshResource: mesh._resource.id
    });
  }
  /**
   * Sets the materials that should be applied to the mesh
   * @param materials array of materials to set
   */
  async setMaterials(materials) {
    this.cachedMaterials = materials;
    await WebSpatial.updateResource(this._resource, {
      materials: materials.map((m) => {
        m._addToComponent(this);
        return m._resource.id;
      })
    });
  }
  /** @hidden */
  async _syncMaterials() {
    await this.setMaterials(this.cachedMaterials);
  }
};

// src/core/component/SpatialViewComponent.ts
var SpatialViewComponent = class extends SpatialComponent {
  /**
   * Sets the resolution of the spatial view in dom pixels
   */
  async setResolution(width, height) {
    await WebSpatial.updateResource(this._resource, {
      resolution: { x: width, y: height }
    });
  }
  /**
   * Sets if content of the spatialView should be within a portal
   * If true, volume will be behind the page, if false, it will be in front of the page
   */
  async setIsPortal(isPortal) {
    await WebSpatial.updateResource(this._resource, {
      isPortal
    });
  }
};

// src/core/component/SpatialModel3DComponent.ts
var SpatialModel3DComponent = class extends EventSpatialComponent {
  onRecvEvent(data) {
    const { eventType, value, error } = data;
    switch (eventType) {
      case "phase":
        if (value === "success") {
          this.onSuccess?.();
        } else {
          this.onFailure?.(error);
        }
        break;
      case "dragstart":
        this._onDragStart?.(value);
        break;
      case "dragend":
        this._onDragEnd?.(value);
        break;
      case "drag":
        this._onDrag?.(value);
        break;
      case "tap":
        this._onTap?.();
        break;
      case "doubletap":
        this._onDoubleTap?.();
        break;
      case "longpress":
        this._onLongPress?.();
        break;
      default:
        break;
    }
  }
  /**
   * Sets the resolution of the spatial view in dom pixels
   */
  async setResolution(width, height) {
    await WebSpatial.updateResource(this._resource, {
      resolution: { x: width, y: height }
    });
  }
  async setRotationAnchor(rotationAnchor) {
    await WebSpatial.updateResource(this._resource, {
      rotationAnchor
    });
  }
  /**
   * Sets the opacity of the model
   * @param opacity
   */
  async setOpacity(opacity) {
    await WebSpatial.updateResource(this._resource, {
      opacity
    });
  }
  /**
   * Sets how the model fill the rect
   * @param contentMode
   */
  async setContentMode(contentMode) {
    await WebSpatial.updateResource(this._resource, {
      contentMode
    });
  }
  /**
   * Constrains this model dimensions to the specified aspect ratio.
   * with a value of 0, the model will use the original aspect ratio.
   *
   * @param aspectRatio number
   */
  async setAspectRatio(aspectRatio) {
    await WebSpatial.updateResource(this._resource, {
      aspectRatio
    });
  }
  /**
   * Defaults to false. If set to true, scrolling the parent page will also scroll this window with it like other dom elements
   * @param scrollWithParent value to set
   */
  async setScrollWithParent(scrollWithParent) {
    await WebSpatial.updateResource(this._resource, {
      scrollWithParent
    });
  }
  /**
   * Sets whether the model appear in original size or fit the rect
   * @param resizable
   */
  async setResizable(resizable) {
    await WebSpatial.updateResource(this._resource, {
      resizable
    });
  }
  /**
   * Callback fired when model load success
   */
  onSuccess;
  /**
   * Callback fired when model load failure
   * @param errorReason
   */
  onFailure;
  /**
   * Callback fired when model was dragged at the beginning
   * @param dragEvent
   */
  _onDragStart;
  set onDragStart(callback) {
    if (this._onDragStart !== callback) {
      this._onDragStart = callback;
      WebSpatial.updateResource(this._resource, {
        enableDragEvent: this.enableDragEvent
      });
    }
  }
  /**
   * Callback fired when model was dragged
   * @param dragEvent
   */
  _onDrag;
  set onDrag(callback) {
    if (this._onDrag !== callback) {
      this._onDrag = callback;
      WebSpatial.updateResource(this._resource, {
        enableDragEvent: this.enableDragEvent
      });
    }
  }
  /**
   * Callback fired when model was dragged at the ending
   * @param dragEvent
   */
  _onDragEnd;
  set onDragEnd(callback) {
    if (this._onDragEnd !== callback) {
      this._onDragEnd = callback;
      WebSpatial.updateResource(this._resource, {
        enableDragEvent: this.enableDragEvent
      });
    }
  }
  get enableDragEvent() {
    return void 0 !== this._onDrag || void 0 !== this._onDragStart || void 0 !== this._onDragEnd;
  }
  /**
   * Callback fired when model was tapped
   */
  _onTap;
  set onTap(callback) {
    if (this._onTap !== callback) {
      this._onTap = callback;
      WebSpatial.updateResource(this._resource, {
        enableTapEvent: void 0 !== callback
      });
    }
  }
  /** Callback fired when model was double tapped */
  _onDoubleTap;
  set onDoubleTap(callback) {
    if (this._onDoubleTap !== callback) {
      this._onDoubleTap = callback;
      WebSpatial.updateResource(this._resource, {
        enableDoubleTapEvent: void 0 !== callback
      });
    }
  }
  /** Callback fired when model was long pressed */
  _onLongPress;
  set onLongPress(callback) {
    if (this._onLongPress !== callback) {
      this._onLongPress = callback;
      WebSpatial.updateResource(this._resource, {
        enableLongPressEvent: void 0 !== callback
      });
    }
  }
};
export {
  Spatial,
  SpatialComponent,
  SpatialEntity,
  SpatialHelper,
  SpatialInputComponent,
  SpatialMeshResource,
  SpatialModel3DComponent,
  SpatialModelComponent,
  SpatialPhysicallyBasedMaterialResource,
  SpatialSession,
  SpatialTransform,
  SpatialViewComponent,
  SpatialWindowComponent,
  SpatialWindowContainer,
  Vec3,
  Vec4
};
//# sourceMappingURL=index.js.map