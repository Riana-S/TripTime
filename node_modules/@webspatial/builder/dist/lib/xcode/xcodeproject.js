"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const resource_1 = require("../resource");
const path_1 = require("path");
const load_1 = require("../resource/load");
const imageHelper_1 = require("../resource/imageHelper");
const manifestSwiftTemplate_1 = require("./manifestSwiftTemplate");
const xcode = require('xcode');
const exportOptionsXML = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>destination</key>
	<string>export</string>
	<key>method</key>
	<string>BUILDTYPE</string>
	<key>signingStyle</key>
	<string>automatic</string>
	<key>stripSwiftSymbols</key>
	<true/>
	<key>teamID</key>
	<string>YOURTEAMID</string>
	<key>thinning</key>
	<string>&lt;none&gt;</string>
</dict>
</plist>`;
const infoPlistXML = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>ITSAppUsesNonExemptEncryption</key>
	<false/>
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleURLName</key>
			<string>web-spatial</string>
			<key>CFBundleURLSchemes</key>
			<array>
				DEEPLINK
			</array>
		</dict>
	</array>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSAllowsArbitraryLoads</key>
		<true/>
	</dict>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationPreferredDefaultSceneSessionRole</key>
		<string>UIWindowSceneSessionRoleApplication</string>
		<key>UIApplicationSupportsMultipleScenes</key>
		<true/>
		<key>UISceneConfigurations</key>
		<dict/>
	</dict>
</dict>
</plist>
`;
let useExportOptionsXML = '';
class XcodeProject {
    static async modify(projectPath, option, isDev = false) {
        let project = xcode.project(projectPath);
        this.fixProjectFunction(project);
        project.parseSync();
        let buildType = option['buildType'];
        const buildTypeOptions = [
            'release-testing',
            'app-store-connect',
            'debugging',
            'enterprise',
        ];
        useExportOptionsXML = exportOptionsXML.replace('BUILDTYPE', buildTypeOptions.includes(buildType) ? buildType : 'release-testing');
        if (option['teamId']) {
            this.updateTeamId(project, option['teamId']);
        }
        this.updateExportOptions();
        if (option.icon)
            await this.bindIcon(option.icon);
        await this.bindManifestInfo(project, option.manifestInfo.json, isDev);
        if (option['version']) {
            this.updateVersion(project, option['version']);
        }
        else {
            this.updateVersion(project, '1.0');
        }
        try {
            fs.writeFileSync(projectPath, project.writeSync());
        }
        catch (error) {
            console.log(error);
        }
    }
    static fixProjectFunction(project) {
        // The original pbxGroupByName method has a bug where the return is null, causing other methods to call. xx directly and report an error
        project.pbxGroupByName = function (name) {
            var groups = this.hash.project.objects['PBXGroup'], key, groupKey;
            for (key in groups) {
                // only look for comments
                if (!/_comment$/.test(key))
                    continue;
                if (groups[key] == name) {
                    groupKey = key.split(/_comment$/)[0];
                    return groups[groupKey];
                }
            }
            // The original method returns null here, causing errors when calling project.pbxGroupByName ("xxx"). xx elsewhere
            return false;
        };
        project.updateBuildProperty = function (prop, value, build, targetName) {
            let validConfigs = [];
            const COMMENT_KEY = /_comment$/;
            if (targetName) {
                const target = this.pbxTargetByName(targetName);
                const targetBuildConfigs = target && target.buildConfigurationList;
                const xcConfigList = this.pbxXCConfigurationList();
                // Collect the UUID's from the configuration of our target
                for (const configName in xcConfigList) {
                    if (!COMMENT_KEY.test(configName) &&
                        targetBuildConfigs === configName) {
                        const buildVariants = xcConfigList[configName].buildConfigurations;
                        for (const item of buildVariants) {
                            validConfigs.push(item.value);
                        }
                        break;
                    }
                }
            }
            var configs = this.pbxXCBuildConfigurationSection();
            for (var configName in configs) {
                if (!COMMENT_KEY.test(configName)) {
                    if (targetName && !validConfigs.includes(configName))
                        continue;
                    var config = configs[configName];
                    if (((build && config.name === build) || !build) &&
                        config.buildSettings[prop]) {
                        config.buildSettings[prop] = value;
                    }
                }
            }
        };
    }
    static async bindIcon(icon) {
        if (icon) {
            // The application icon of Apple Vision Pro requires at least 2 images, one of which is a completely opaque base image. Therefore, Spatial Web is required to provide the base image, and CLI will generate an additional completely transparent image as the middle layer.
            const iconConfigDirectory = (0, path_1.join)(resource_1.PROJECT_DIRECTORY, resource_1.BACK_APPICON_DIRECTORY);
            const iconConfigPath = (0, path_1.join)(iconConfigDirectory, 'Contents.json');
            const iconFileName = 'icon.' + icon.getMIME().replace('image/', '');
            const iconFullPath = (0, path_1.join)(iconConfigDirectory, iconFileName);
            let iconConfig = await (0, load_1.loadJsonFromDisk)(iconConfigPath);
            /*
                JSON format for icon configuration in Xcode
                {
                    images: [ { filename: 'icon.jpeg', idiom: 'vision', scale: '2x' } ],
                    info: { author: 'xcode', version: 1 }
                }
            */
            iconConfig.images[0]['filename'] = iconFileName;
            await icon.writeAsync(iconFullPath);
            await fs.writeFileSync(iconConfigPath, JSON.stringify(iconConfig));
            const middleIconConfigDirectory = (0, path_1.join)(resource_1.PROJECT_DIRECTORY, resource_1.MIDDLE_APPICON_DIRECTORY);
            const middleIconConfigPath = (0, path_1.join)(middleIconConfigDirectory, 'Contents.json');
            const middleIconFileName = 'icon.png';
            const middleIconFullPath = (0, path_1.join)(middleIconConfigDirectory, middleIconFileName);
            let middleConfig = await (0, load_1.loadJsonFromDisk)(middleIconConfigPath);
            let middleIcon = imageHelper_1.ImageHelper.createImg(512);
            middleConfig.images[0]['filename'] = middleIconFileName;
            await middleIcon.writeAsync(middleIconFullPath);
            await fs.writeFileSync(middleIconConfigPath, JSON.stringify(middleConfig));
            const logoConfigDirectory = (0, path_1.join)(resource_1.PROJECT_DIRECTORY, resource_1.LOGO_DIRECTORY);
            const logoConfigPath = (0, path_1.join)(logoConfigDirectory, 'Contents.json');
            let logoConfig = await (0, load_1.loadJsonFromDisk)(logoConfigPath);
            const logoFileName = 'logo.' + icon.getMIME().replace('image/', '');
            const logoFullPath = (0, path_1.join)(logoConfigDirectory, logoFileName);
            logoConfig.images[0]['filename'] = logoFileName;
            await icon.writeAsync(logoFullPath);
            await fs.writeFileSync(logoConfigPath, JSON.stringify(logoConfig));
        }
    }
    static updateTeamId(xcodeProject, teamId) {
        xcodeProject.updateBuildProperty('DEVELOPMENT_TEAM', teamId);
        useExportOptionsXML = useExportOptionsXML.replace('YOURTEAMID', teamId);
    }
    static updateExportOptions() {
        if (!fs.existsSync(resource_1.PROJECT_BUILD_DIRECTORY)) {
            fs.mkdirSync(resource_1.PROJECT_BUILD_DIRECTORY, { recursive: true });
        }
        fs.writeFileSync((0, path_1.join)(resource_1.PROJECT_BUILD_DIRECTORY, 'ExportOptions.plist'), useExportOptionsXML);
    }
    static async bindManifestInfo(xcodeProject, manifest, isDev = false) {
        var _a;
        xcodeProject.updateProductName(manifest.name);
        // set PRODUCT_BUNDLE_IDENTIFIER need ""
        if (manifest.id) {
            xcodeProject.updateBuildProperty('PRODUCT_BUNDLE_IDENTIFIER', `"${manifest.id}"`);
        }
        this.updateDeeplink((_a = manifest.protocol_handlers) !== null && _a !== void 0 ? _a : []);
        await this.modifySwift(manifest);
    }
    static updateVersion(xcodeProject, version) {
        xcodeProject.updateBuildProperty('CURRENT_PROJECT_VERSION', version);
    }
    static updateDeeplink(deeplinks) {
        let infoPlistPath = (0, path_1.join)(resource_1.PROJECT_DIRECTORY, './web-spatial/Info.plist');
        let deeplinkString = '';
        for (let i = 0; i < deeplinks.length; i++) {
            deeplinkString += `<string>${deeplinks[i].protocol}</string>`;
        }
        const newInfoPlist = infoPlistXML.replace('DEEPLINK', deeplinkString);
        fs.writeFileSync(infoPlistPath, newInfoPlist);
    }
    static async modifySwift(manifest) {
        var _a;
        const manifestSwiftPath = (0, path_1.join)(resource_1.PROJECT_DIRECTORY, './web-spatial/libs/webView/manifest.swift');
        const xcodePackageJsonPath = (0, path_1.join)(resource_1.PROJECT_DIRECTORY, 'package.json');
        const packageJson = await (0, load_1.loadJsonFromDisk)(xcodePackageJsonPath);
        let manifestSwift = manifestSwiftTemplate_1.manifestSwiftTemplate;
        manifestSwift = manifestSwift.replace('PACKAGE_VERSION', (_a = packageJson.version) !== null && _a !== void 0 ? _a : '0.0.0');
        manifestSwift = manifestSwift.replace('START_URL', manifest.start_url);
        manifestSwift = manifestSwift.replace('SCOPE', manifest.scope);
        manifestSwift = manifestSwift.replace('AppName', manifest.name);
        manifestSwift = manifestSwift.replace('Description', manifest.description);
        manifestSwift = manifestSwift.replace('AppID', manifest.id);
        manifestSwift = manifestSwift.replace('.minimal', manifest.display == 'minimal-ui' ? '.minimal' : `.${manifest.display}`);
        if (manifest.protocol_handlers) {
            let deeplinkString = '';
            for (let i = 0; i < manifest.protocol_handlers.length; i++) {
                deeplinkString += `PWAProtocol(protocolValue: "${manifest.protocol_handlers[i].protocol}", url: "${manifest.protocol_handlers[i].url}"),`;
            }
            manifestSwift = manifestSwift.replace('PWAProtocol(protocolValue: "", url: "")', deeplinkString);
        }
        manifestSwift = manifestSwift.replace('SceneWidth', manifest.xr_main_scene.defaultSize.width);
        manifestSwift = manifestSwift.replace('SceneHeight', manifest.xr_main_scene.defaultSize.height);
        let res = 'nil';
        const resizabilities = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'];
        if (manifest.xr_main_scene.resizability) {
            res = 'ResizeRange(';
            for (var i = 0; i < resizabilities.length; i++) {
                if (manifest.xr_main_scene.resizability[resizabilities[i]] >= 0) {
                    res += `${resizabilities[i]}: ${manifest.xr_main_scene.resizability[resizabilities[i]]},`;
                }
            }
            res = res.substring(0, res.length - 1);
            res += ')';
        }
        manifestSwift = manifestSwift.replace('SceneResizability', res);
        fs.writeFileSync(manifestSwiftPath, manifestSwift, 'utf-8');
    }
}
exports.default = XcodeProject;
