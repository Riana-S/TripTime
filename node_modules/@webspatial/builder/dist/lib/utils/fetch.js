"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetch = fetch;
exports.downloadFile = downloadFile;
exports.decompressResponseBuffer = decompressResponseBuffer;
const fetch_h2_1 = require("fetch-h2");
const fs = require("fs");
const zlib = require("zlib");
// const userAgent = 'Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/81.0';
const userAgent = 'Mozilla/5.0 (X11; Linux x86_64; PICO 4 OS5.5.0 like Quest) AppleWebKit/537.36 (KHTML, like Gecko) PicoBrowser/3.3.24 Chrome/105.0.5195.68 VR Safari/537.36  OculusBrowser/7.0';
const fetchh2Ctx = (0, fetch_h2_1.context)({ userAgent: userAgent, overwriteUserAgent: true });
const fetchh2 = fetchh2Ctx.fetch;
async function fetch(input, headers) {
    return await fetchh2(input, headers ? { redirect: 'follow', ...headers } : { redirect: 'follow' });
}
async function downloadFile(url, path, progressCallback) {
    let result;
    let readableStream;
    result = await fetchh2(url, { redirect: 'follow' });
    readableStream = await result.readable();
    // Try to determine the file size via the `Content-Length` header. This may not be available
    // for all cases.
    const contentLength = result.headers.get('Content-Length');
    const fileSize = contentLength ? parseInt(contentLength) : -1;
    const fileStream = fs.createWriteStream(path);
    let received = 0;
    await new Promise((resolve, reject) => {
        readableStream.pipe(fileStream);
        // Even though we're piping the chunks, we intercept them to check for the download progress.
        if (progressCallback) {
            readableStream.on('data', chunk => {
                received = received + chunk.length;
                progressCallback(received, fileSize);
            });
        }
        readableStream.on('error', err => {
            reject(err);
        });
        fileStream.on('finish', () => {
            resolve();
        });
    });
}
function decompressResponseBuffer(buffer, contentEncoding) {
    let result = buffer;
    if (/\bgzip\b/.test(contentEncoding) || /\bdeflate\b/.test(contentEncoding)) {
        result = zlib.unzipSync(buffer, {
            flush: zlib.constants.Z_SYNC_FLUSH,
            finishFlush: zlib.constants.Z_SYNC_FLUSH,
        });
    }
    else if (/\bbr\b/.test(contentEncoding)) {
        result = zlib.brotliDecompressSync(buffer);
    }
    return result;
}
