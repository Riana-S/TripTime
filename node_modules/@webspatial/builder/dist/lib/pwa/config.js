"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safelist = void 0;
exports.configId = configId;
exports.configStartUrl = configStartUrl;
exports.configScope = configScope;
exports.configDisplay = configDisplay;
exports.configMainScene = configMainScene;
exports.configDeeplink = configDeeplink;
const utils_1 = require("../utils/utils");
const validate_1 = require("./validate");
const path_1 = require("path");
function configId(manifestJson, bundleId) {
    if (bundleId) {
        manifestJson.id = bundleId;
    }
    else {
        try {
            const url = new URL(manifestJson.id);
            let arr = url.host.split('.').reverse();
            manifestJson.id = arr.join('.');
        }
        catch (e) {
            throw new Error(`id:${manifestJson.id}  is not a valid url`);
        }
    }
}
function configStartUrl(manifestJson, base, manifestUrl, isNet) {
    var _a;
    let start_url = (_a = manifestJson.start_url) !== null && _a !== void 0 ? _a : '/';
    const isStartUrl = (0, validate_1.validateURL)(start_url);
    const hasBase = base.length > 0;
    if (hasBase) {
        const isBaseUrl = (0, validate_1.validateURL)(base);
        if (!isStartUrl && !isBaseUrl) {
            const staticWebRoot = (0, path_1.resolve)('./static-web');
            const resolvedPath = (0, path_1.join)(base, start_url);
            const normalizedPath = (0, path_1.normalize)(resolvedPath);
            const safePath = (0, path_1.join)(staticWebRoot, normalizedPath);
            start_url = (0, path_1.relative)(process.cwd(), safePath)
                .replace(/^(\.\.\/)+/, './')
                .replace(/\/$/, '');
        }
        else if (isStartUrl && !isBaseUrl) {
            const startUrl = new URL(start_url);
            const fullPath = startUrl.pathname + startUrl.search + startUrl.hash;
            let newBase = new URL(base, startUrl.origin);
            start_url = new URL(fullPath, newBase).href;
        }
        else if (!isStartUrl && isBaseUrl) {
            if (start_url.startsWith('/')) {
                const baseUrl = new URL(base);
                start_url = baseUrl.origin + (0, path_1.join)(baseUrl.pathname, start_url);
            }
            else {
                start_url = new URL(start_url, base).href;
            }
        }
        else if (isStartUrl && isBaseUrl) {
            const startUrl = new URL(start_url);
            const baseUrl = new URL(base);
            const startFullPath = startUrl.pathname + startUrl.search + startUrl.hash;
            start_url = new URL(startFullPath, baseUrl.origin + baseUrl.pathname).href;
        }
    }
    else {
        if (isNet) {
            const murl = new URL(manifestUrl);
            if (!isStartUrl) {
                const newStartUrl = new URL(start_url, murl.origin);
                start_url = newStartUrl.href;
            }
            else {
                const startUrl = new URL(start_url);
                start_url =
                    murl.origin + startUrl.pathname + startUrl.search + startUrl.hash;
            }
        }
        else if (!isStartUrl) {
            const staticWebRoot = (0, path_1.resolve)('./static-web');
            const resolvedPath = (0, path_1.resolve)(staticWebRoot, start_url);
            const normalizedPath = (0, path_1.normalize)(resolvedPath);
            const safePath = (0, path_1.join)(staticWebRoot, normalizedPath);
            start_url = (0, path_1.relative)(process.cwd(), safePath)
                .replace(/^(\.\.\/)+/, './')
                .replace(/\/$/, '');
        }
    }
    if (!start_url.match(/\.html(\?|$)/) &&
        !(start_url.startsWith('http://') || start_url.startsWith('https://'))) {
        const [path, query] = start_url.split('?');
        start_url = path.endsWith('/') ? `${path}index.html` : `${path}/index.html`;
        if (query)
            start_url += `?${query}`;
    }
    return start_url;
}
function configScope(manifestJson) {
    var _a;
    let scope = (_a = manifestJson.scope) !== null && _a !== void 0 ? _a : '/';
    const isStartUrl = (0, validate_1.validateURL)(manifestJson.start_url);
    const isUrl = (0, validate_1.validateURL)(scope);
    if (isStartUrl && isUrl) {
        const scopeURL = new URL(scope);
        const startURL = new URL(manifestJson.start_url);
        if (scopeURL.host !== startURL.host ||
            manifestJson.start_url.indexOf(scope) !== 0) {
            scope = (0, utils_1.parseRouter)(manifestJson.start_url);
        }
    }
    else if (isStartUrl && !isUrl) {
        scope = new URL(scope, manifestJson.start_url).href;
    }
    else if (!isStartUrl && isUrl) {
        const cleanPath = manifestJson.start_url.replace(/\/[^\/]+$/, '');
        scope = (0, path_1.normalize)(cleanPath + '/');
    }
    else {
        scope = (0, path_1.join)((0, utils_1.parseRouter)(manifestJson.start_url), scope);
    }
    manifestJson.scope = scope;
}
function configDisplay(manifestJson) {
    let display = manifestJson.display;
    const modes = ['minimal-ui', 'standalone', 'fullscreen'];
    if (!modes.includes(display)) {
        display = 'standalone';
    }
    if (manifestJson.display_override &&
        manifestJson.display_override.length > 0) {
        const validModes = manifestJson.display_override
            .map((mode, index) => ({ mode, index }))
            .filter(({ mode }) => modes.includes(mode))
            .sort((a, b) => a.index - b.index);
        if (validModes.length > 0) {
            display = validModes[0].mode;
        }
    }
    manifestJson.display = display;
}
function configMainScene(manifestJson) {
    var _a, _b;
    const resizabilities = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'];
    let mainScene = {
        defaultSize: {
            width: 1280,
            height: 1280,
        },
        resizability: {},
    };
    let hasResizability = false;
    if (manifestJson.xr_main_scene &&
        typeof manifestJson.xr_main_scene === 'object') {
        mainScene.defaultSize.width =
            Number((_a = manifestJson.xr_main_scene.default_size) === null || _a === void 0 ? void 0 : _a.width) > 0
                ? manifestJson.xr_main_scene.default_size.width
                : 1280;
        mainScene.defaultSize.height =
            Number((_b = manifestJson.xr_main_scene.default_size) === null || _b === void 0 ? void 0 : _b.height) > 0
                ? manifestJson.xr_main_scene.default_size.height
                : 1280;
        if (typeof manifestJson.xr_main_scene.resizability === 'object') {
            for (var i = 0; i < resizabilities.length; i++) {
                if (manifestJson.xr_main_scene.resizability[resizabilities[i]] >= 0) {
                    hasResizability = true;
                    mainScene.resizability[resizabilities[i]] =
                        manifestJson.xr_main_scene.resizability[resizabilities[i]];
                }
            }
        }
    }
    if (!hasResizability) {
        mainScene.resizability = null;
    }
    manifestJson.xr_main_scene = mainScene;
}
function configDeeplink(manifestJson) {
    if (manifestJson.protocol_handlers &&
        manifestJson.protocol_handlers.length > 0) {
        for (var i = 0; i < manifestJson.protocol_handlers.length; i++) {
            const item = manifestJson.protocol_handlers[i];
            // The DeepLink protocol must be on the security list or start with web+
            if (item.protocol &&
                (exports.safelist.includes(item.protocol) ||
                    item.protocol.indexOf('web+') === 0)) {
                // If the URL is an absolute path, it must be within the scope range
                if (!((0, validate_1.validateURL)(item.url) && item.url.indexOf(manifestJson.scope) < 0))
                    continue;
            }
            manifestJson.protocol_handlers.splice(i, 1);
            i--;
        }
    }
}
exports.safelist = [
    'bitcoin',
    'ftp',
    'ftps',
    'geo',
    'im',
    'irc',
    'ircs',
    'magnet',
    'mailto',
    'matrix',
    'mms',
    'news',
    'nntp',
    'openpgp4fpr',
    'sftp',
    'sip',
    'sms',
    'smsto',
    'ssh',
    'tel',
    'urn',
    'webcal',
    'wtai',
    'xmpp',
];
